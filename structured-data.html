<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Structured data</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="css/base.css" />
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
  <script src="js/exercise-list.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@3.3.7/dist/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <ul class="nav navbar-nav">
      <li>
        <a href="index.html">← index</a>
      </li>
      <li>
        <button type="button"
                class="btn btn-default navbar-btn"
                data-toggle="collapse" data-target="#exercise-list">
          Exercises
        </button>
      </li>
      <li>
        <ul id="exercise-list" class="collapse navbar-text list-inline">
        </ul>
      </li>
  </div>
</nav>
<div class="container">
  <div class="main-content">
<header id="title-block-header">
<h1 class="title">Structured data</h1>
</header>
<section class="alert alert-info">
<h3>
Hint
</h3>
<p>The following web pages are good references to Clojure builtins and
data structures:</p>
<ul>
<li><a href="http://clojuredocs.org">ClojureDocs</a></li>
<li><a href="http://clojure.org/cheatsheet">Clojure cheatsheet</a></li>
</ul>
</section>
<section id="fork-this" class="level2">
<h2>Fork this</h2>
<p><a
href="https://github.com/iloveponies/structured-data">https://github.com/iloveponies/structured-data</a></p>
<p><a
href="basic-tools.html#how-to-submit-answers-to-exercises">Here</a> are
the instructions if you need them. Be sure to fork the repository behind
the link above.</p>
</section>
<section id="let-there-be-names" class="level2">
<h2>Let there be names</h2>
<p>We often want to give a piece of data name, either because the act of
naming gives clarity to the code, or because we want to refer to the
data many times. As we have seen, namespace global names are declared
with <code>def</code>. A function or value that is needed only inside
one function can be given a <em>local name</em> with
<code>let</code>.</p>
<p>As an example, let’s define a function for calculating the length of
a triangle’s hypotenuse, given the length of its two legs:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> hypotenuse </span>[x y]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> [xx (<span class="kw">*</span> x x)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        yy (<span class="kw">*</span> y y)]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    (Math/sqrt (<span class="kw">+</span> xx yy))))</span></code></pre></div>
<p>Here we give the expressions <code>(* x x)</code> and
<code>(* y y)</code> the local names <code>xx</code> and
<code>yy</code>, respectively. They are visible only inside
<code>hypotenuse</code>.</p>
<p><code>let</code> introduces one or more names and a scope for
them:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> [name1 value1</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>      name2 value2</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>      ...]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>  (expression1)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  (expression2)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>  ...)</span></code></pre></div>
<p>The names introduced by <code>let</code> are visible in all the
expressions after them, under <code>let</code>. A name is not visible to
code outside the body of the <code>let</code> it is defined in.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>user=&gt; (<span class="kw">let</span> [x <span class="dv">42</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>         (<span class="kw">+</span> x x))</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; 84</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>user=&gt; x</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>CompilerException java.lang.RuntimeException:</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>Unable to <span class="kw">resolve</span> symbol: x in this context, compiling:(NO_SOURCE_PATH<span class="at">:0</span>) </span></code></pre></div>
<p>Note the indentation in <code>let</code>: the names inside the
brackets are all aligned together, and the expressions are indented with
two spaces.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> [x <span class="dv">42</span>]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  (indented x))</span></code></pre></div>
<section class="alert alert-success">
<h3>
Exercise 1
</h3>
<p>The following function does a thing:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> do-a-thing </span>[x]</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  (Math/pow (<span class="kw">+</span> x x) (<span class="kw">+</span> x x)))</span></code></pre></div>
Change the function <code>do-a-thing</code> so that it uses
<code>let</code> to give a name to the common expression
<code>(+ x x)</code> in its body.
</section>
<p>The names declared in a <code>let</code> expression can refer to
previous names in the same expression:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> [a <span class="dv">10</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>      b (<span class="kw">+</span> a <span class="dv">8</span>)]</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">+</span> a b))</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; 28</span></span></code></pre></div>
<p>In the example above, <code>b</code> can refer to <code>a</code>
because <code>a</code> is declared before it. On the other hand,
<code>a</code> can not refer to b:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> [a (<span class="kw">+</span> b <span class="dv">42</span>)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>      b <span class="dv">8</span>]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">+</span> a b))</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="co">; CompilerException java.lang.RuntimeException: Unable to resolve symbol:</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="co">; b in this context, compiling:(NO_SOURCE_PATH:1)</span></span></code></pre></div>
</section>
<section id="simple-values" class="level2">
<h2>Simple values</h2>
<p>Now that we know how to give names to values, let’s look at what kind
of values Clojure supports.</p>
<p>Scalar values are the regular, singular simple values like
<code>42</code>, <code>"foo"</code> or <code>true</code>. The following
table describes some of them.</p>
<table style="width:100%;">
<colgroup>
<col style="width: 20%" />
<col style="width: 26%" />
<col style="width: 53%" />
</colgroup>
<thead>
<tr class="header">
<th>Type</th>
<th>Examples</th>
<th style="text-align: left;">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Numbers</td>
<td><code>42</code>, <code>3/2</code>, <code>2.1</code></td>
<td style="text-align: left;">Numbers include integers, fractions, and
floats.</td>
</tr>
<tr class="even">
<td>Strings</td>
<td><code>"foo"</code></td>
<td style="text-align: left;">Text values.</td>
</tr>
<tr class="odd">
<td>Characters</td>
<td><code>\x</code>, <code>\y</code>, <code>\√</code></td>
<td style="text-align: left;">A single characer is written with a
preceding <code>\</code>.</td>
</tr>
<tr class="even">
<td>Keywords</td>
<td><code>:foo</code>, <code>:?</code></td>
<td style="text-align: left;">Values often used as map keys.</td>
</tr>
<tr class="odd">
<td>Booleans</td>
<td><code>true</code>, <code>false</code></td>
<td style="text-align: left;">Boolean values.</td>
</tr>
</tbody>
</table>
</section>
<section id="vectors" class="level2">
<h2>Vectors</h2>
<p>Collections are the other kind of values, in addition to scalars,
that are crucial to programming. Clojure has support for a rich set of
collection data structures. We’ll go over the most important structures
in this chapter.</p>
<p>A <em>vector</em> is a collection that can be indexed with integers,
like an array in other languages. It can contain values of different
types.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>[<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]                 <span class="co">;=&gt; [1 2 3]</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>[<span class="at">:foo</span> <span class="dv">42</span> <span class="st">&quot;bar&quot;</span> (<span class="kw">+</span> <span class="dv">2</span> <span class="dv">3</span>)] <span class="co">;=&gt; [:foo 42 &quot;bar&quot; 5]</span></span></code></pre></div>
<p>A vector is written with surrounding brackets, <code>[]</code>, and
the elements are written inside, separated by whitespace and optionally
commas (<code>,</code>).</p>
<p>Vectors are indexed with the <code>get</code> function:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">get</span> [<span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span> <span class="st">&quot;c&quot;</span>] <span class="dv">1</span>)  <span class="co">;=&gt; &quot;b&quot;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">get</span> [<span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span> <span class="st">&quot;c&quot;</span>] <span class="dv">15</span>) <span class="co">;=&gt; nil</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">get</span> [<span class="st">&quot;x&quot;</span>] <span class="dv">0</span>)          <span class="co">;=&gt; &quot;x&quot;</span></span></code></pre></div>
<p>Trying to index a vector beyond its size does <em>not</em> throw an
exception. The special value <code>nil</code> is returned, instead.</p>
<section class="alert alert-success">
<h3>
Exercise 2
</h3>
<p>Write the function <code>(spiff v)</code> that takes a vector and
returns the sum of the first and third elements of the vector. What
happens when you pass in a vector that is too short?</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>(spiff [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])       <span class="co">;=&gt; 4</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>(spiff [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>]) <span class="co">;=&gt; 4</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>(spiff [<span class="dv">1</span> <span class="dv">2</span>])         <span class="co">;=&gt; ?</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>(spiff [])            <span class="co">;=&gt; ?</span></span></code></pre></div>
</section>
<section id="basic-vector-operations" class="level3">
<h3>Basic vector operations</h3>
<p>Vectors are immutable: once you have a vector, <em>you can not change
it</em>. You can, however, easily create new vectors based on a
vector:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">conj</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>] <span class="dv">4</span>)          <span class="co">;=&gt; [1 2 3 4]</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">assoc</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>] <span class="dv">2</span> <span class="st">&quot;foo&quot;</span>) <span class="co">;=&gt; [1 2 &quot;foo&quot; 4]</span></span></code></pre></div>
<p><code>conj</code> adds a value to a collection. Its behaviour depends
on the type of collection: with vectors, it adds the value to the end of
the vector. To be exact, <code>conj</code> does <em>not</em> change the
given vector. Instead, it returns a new vector, based on the given
vector, with the new element appended to the end.</p>
<section class="alert alert-success">
<h3>
Exercise 3
</h3>
<p>Write the function <code>(cutify v)</code> that takes a vector as a
parameter and adds <code>"&lt;3"</code> to its end.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>(cutify []) =&gt; [<span class="st">&quot;&lt;3&quot;</span>]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>(cutify [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) =&gt; [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="st">&quot;&lt;3&quot;</span>]</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>(cutify [<span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span>]) =&gt; [<span class="st">&quot;a&quot;</span> <span class="st">&quot;b&quot;</span> <span class="st">&quot;&lt;3&quot;</span>]</span></code></pre></div>
<!-- "> -->
</section>
</section>
<section id="vectors-a-postmodern-deconstruction" class="level3">
<h3>Vectors: A Postmodern Deconstruction</h3>
<p>Another way of extracting values from a vector is by
<em>destructuring</em> it:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> [[x y z] [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span> <span class="dv">5</span> <span class="dv">6</span>]]</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">str</span> x y z))</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; &quot;123&quot;</span></span></code></pre></div>
<p>Here, instead of giving a name to the vector
<code>[1 2 3 4 5 6]</code>, we indicate with the brackets in
<code>[x y z]</code> that we want to destructure the vector instead.
Inside the brackets, we give names to the first three elements of the
vector. <code>x</code> will be given the value of the first element,
<code>1</code>; <code>b</code> will be <code>2</code> and <code>c</code>
will be <code>3</code>. The concatenation of these values that
<code>str</code> returns is <code>"123"</code>.</p>
<section class="alert alert-success">
<h3>
Exercise 4
</h3>
Rewrite our earlier function <code>spiff</code> by destructuring its
parameter. Call this new function <code>spiff-destructuring</code>.
</section>
<p>You can destructure function parameters directly. For an example,
take the following function:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> sum-pairs </span>[first-pair second-pair]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  [(<span class="kw">+</span> (<span class="kw">first</span>  first-pair) (<span class="kw">first</span>  second-pair))</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>   (<span class="kw">+</span> (<span class="kw">second</span> first-pair) (<span class="kw">second</span> second-pair))])</span></code></pre></div>
<p>The function takes two vectors and sums the elements pairwise:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>(sum-pairs [<span class="dv">42</span> <span class="dv">5</span>]   [-<span class="dv">42</span> -<span class="dv">5</span>])   <span class="co">;=&gt; [0 0]</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>(sum-pairs [<span class="dv">64</span> <span class="dv">256</span>] [-<span class="dv">51</span> -<span class="dv">219</span>]) <span class="co">;=&gt; [13 37]</span></span></code></pre></div>
<p><code>sum-pair</code> is not very pretty to look at. We can spiff it
up by taking out the elements of its parameter vectors by destructuring
them:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> sum-pairs </span>[[x1 y1] [x2 y2]]</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>  [(<span class="kw">+</span> x1 x2) (<span class="kw">+</span> y1 y2)])</span></code></pre></div>
<p><code>sum-pairs</code> still takes two parameter vectors, but now it
does not give names to its parameters. Instead, it gives names to their
first two elements by destructuring the parameters. We could have also
destructured the parameters with a <code>let</code>.</p>
</section>
</section>
<section id="thinking-with-boxes" class="level2">
<h2>Thinking With Boxes</h2>
<p>Let’s define a simple representation for a two-dimensional point. It
will simply be a pair (2-element vector) of two numbers.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> point </span>[x y]</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  [x y])</span></code></pre></div>
<p>And a representation for a rectangle. This will simply be a pair of
points, the first being the bottom left corner and the second being the
top left corner.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> rectangle </span>[bottom-left top-right]</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>  [bottom-left top-right])</span></code></pre></div>
<p>When you have nested structures where you know their structure in
advance, you can destructure multiple levels at a time.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> [[[x1 y1] [x2 y2]] rectangle]</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>  ... <span class="kw">do</span> stuff with coordinates)</span></code></pre></div>
<p>This should prove to be useful in the following exercises.</p>
<section class="alert alert-success">
<h3>
Exercise 5
</h3>
<p>Write the functions <code>(height rectangle)</code> and
<code>(width rectangle)</code> that return the height and width of the
given rectangle. Use destructuring.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>(height (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">5</span> <span class="dv">1</span>])) =&gt; <span class="dv">0</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>(height (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">5</span> <span class="dv">5</span>])) =&gt; <span class="dv">4</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>(height (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">2</span> <span class="dv">3</span>])) =&gt; <span class="dv">3</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>(width (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">5</span> <span class="dv">1</span>]))  =&gt; <span class="dv">4</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>(width (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">1</span> <span class="dv">1</span>]))  =&gt; <span class="dv">0</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>(width (rectangle [<span class="dv">3</span> <span class="dv">1</span>] [<span class="dv">10</span> <span class="dv">4</span>])) =&gt; <span class="dv">7</span></span></code></pre></div>
</section>
<section class="alert alert-success">
<h3>
Exercise 6
</h3>
<p>Write the function <code>(square? rectangle)</code> that returns
<code>true</code> if <code>rectangle</code> is a square and otherwise
<code>false</code>.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>(square? (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">2</span> <span class="dv">2</span>])) <span class="co">;=&gt; true</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>(square? (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">2</span> <span class="dv">3</span>])) <span class="co">;=&gt; false</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>(square? (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">1</span> <span class="dv">1</span>])) <span class="co">;=&gt; true</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>(square? (rectangle [<span class="dv">3</span> <span class="dv">2</span>] [<span class="dv">1</span> <span class="dv">0</span>])) <span class="co">;=&gt; true</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>(square? (rectangle [<span class="dv">3</span> <span class="dv">2</span>] [<span class="dv">1</span> <span class="dv">1</span>])) <span class="co">;=&gt; false</span></span></code></pre></div>
</section>
<section class="alert alert-success">
<h3>
Exercise 7
</h3>
<p>Write the function <code>(area rectangle)</code> that returns the
area of the given rectangle.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>(area (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">5</span> <span class="dv">1</span>]))  =&gt; <span class="dv">0</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>(area (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">1</span> <span class="dv">1</span>]))  =&gt; <span class="dv">1</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>(area (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">4</span> <span class="dv">3</span>]))  =&gt; <span class="dv">12</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a>(area (rectangle [<span class="dv">3</span> <span class="dv">1</span>] [<span class="dv">10</span> <span class="dv">4</span>])) =&gt; <span class="dv">21</span></span></code></pre></div>
</section>
<section class="alert alert-success">
<h3>
Exercise 8
</h3>
<p>Write the function <code>(contains-point? rectangle point)</code>
that returns <code>true</code> if <code>rectangle</code> contains
<code>point</code> and otherwise <code>false</code>.</p>
<p>Remember that you can give <code>&lt;=</code> multiple parameters.
<code>(&lt;= x y z)</code> returns <code>true</code> if <span
class="math inline">\(x \leq y \leq z\)</span> holds. Otherwise
<code>false</code>.</p>
<!-- >> -->
<p>Hint: <code>and</code> is useful.</p>
<p>use destructuring.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>(contains-point? (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">2</span> <span class="dv">2</span>])</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>                 (point <span class="dv">1</span> <span class="dv">1</span>))            <span class="co">;=&gt; true</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>(contains-point? (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">2</span> <span class="dv">2</span>])</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>                 (point <span class="dv">2</span> <span class="dv">1</span>))            <span class="co">;=&gt; true</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>(contains-point? (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">2</span> <span class="dv">2</span>])</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>                 (point -<span class="dv">3</span> <span class="dv">1</span>))           <span class="co">;=&gt; false</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>(contains-point? (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">2</span> <span class="dv">2</span>])</span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>                 (point <span class="dv">1</span> <span class="dv">3</span>))            <span class="co">;=&gt; false</span></span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>(contains-point? (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">2</span> <span class="dv">2</span>])</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>                 (point <span class="dv">1</span> <span class="dv">1</span>))            <span class="co">;=&gt; true</span></span>
<span id="cb23-11"><a href="#cb23-11" aria-hidden="true" tabindex="-1"></a>(contains-point? (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">1</span> <span class="dv">1</span>])</span>
<span id="cb23-12"><a href="#cb23-12" aria-hidden="true" tabindex="-1"></a>                 (point <span class="dv">1</span> <span class="dv">1</span>))            <span class="co">;=&gt; true</span></span></code></pre></div>
</section>
<section class="alert alert-success">
<h3>
Exercise 9
</h3>
<p>Write the function <code>(contains-rectangle? outer inner)</code>
that returns <code>true</code> if the rectangle <code>inner</code> is
inside the rectangle <code>outer</code> and otherwise
<code>false</code>.</p>
<p>Hint: use <code>contains-point?</code></p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>(contains-rectangle? (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">3</span> <span class="dv">3</span>])</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>                     (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">2</span> <span class="dv">2</span>])) <span class="co">;=&gt; true</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>(contains-rectangle? (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">2</span> <span class="dv">2</span>])</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>                     (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">3</span> <span class="dv">3</span>])) <span class="co">;=&gt; false</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>(contains-rectangle? (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">1</span> <span class="dv">1</span>])</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>                     (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">1</span> <span class="dv">1</span>])) <span class="co">;=&gt; true</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>(contains-rectangle? (rectangle [<span class="dv">0</span> <span class="dv">0</span>] [<span class="dv">1</span> <span class="dv">1</span>])</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>                     (rectangle [<span class="dv">1</span> <span class="dv">1</span>] [<span class="dv">2</span> <span class="dv">2</span>])) <span class="co">;=&gt; false</span></span></code></pre></div>
</section>
</section>
<section id="maps" class="level2">
<h2>Maps</h2>
<p>Where a vector associates integers to values, a <em>map</em> is not
restricted to integer keys. You can use any kind of value as a key. A
map is written with curly brackets, <code>{}</code>.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>{<span class="st">&quot;foo&quot;</span> <span class="dv">42</span>, <span class="st">&quot;bar&quot;</span> <span class="dv">666</span>}</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>{<span class="st">&quot;mehmeh&quot;</span> (<span class="kw">+</span> <span class="dv">2</span> <span class="dv">5</span>)</span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a> <span class="st">&quot;rupatipor&quot;</span> <span class="st">&quot;ropopo&quot;</span>}</span></code></pre></div>
<p>A map is indexed with the <code>get</code> function:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> [ages {<span class="st">&quot;Juhana&quot;</span> <span class="dv">3</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;Ilmari&quot;</span> <span class="dv">42</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;King of All Cosmos&quot;</span> -<span class="dv">6</span>}]</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">get</span> ages <span class="st">&quot;King of All Cosmos&quot;</span>))</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; -6</span></span></code></pre></div>
<p>In idiomatic Clojure programs, the keys of a map are often
<em>keywords</em>. Keywords are a convenient way of naming keys for
values in associative collections such as maps. They are written with a
preceding <code>:</code>.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> book </span>{<span class="at">:title</span> <span class="st">&quot;The City and the City&quot;</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>           <span class="at">:authors</span> [{<span class="at">:name</span> <span class="st">&quot;China Miéville&quot;</span>, <span class="at">:birth-year</span> <span class="dv">1972</span>}]})</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">get</span> book <span class="at">:title</span>) <span class="co">;=&gt; &quot;The City and the City&quot;</span></span></code></pre></div>
<p>Keywords are even more convenient than this. They work as functions
that access collections:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>(<span class="at">:title</span> book) <span class="co">;=&gt; &quot;The City and the City&quot;</span></span></code></pre></div>
<p>When used as a function and given a collection, a keyword looks
itself up in the collection and returns the value associated with
it.</p>
<section id="we-are-a-legion" class="level3">
<h3>We are a legion</h3>
<p><code>count</code> can be used to find out the amount of elements in
a collection.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">count</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">;=&gt; 3</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">count</span> {<span class="at">:name</span> <span class="st">&quot;China Miéville&quot;</span>, <span class="at">:birth-year</span> <span class="dv">1972</span>}) =&gt; <span class="dv">2</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">count</span> <span class="st">&quot;:)&quot;</span>) =&gt; <span class="dv">2</span></span></code></pre></div>
<p>As we can see, <code>count</code> tells the amount of keys for a map
and the amount of elements for a vector. It can also be used to find out
the length of a string.</p>
<p>Let’s define some authors and a couple of books with maps and
vectors.</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> china </span>{<span class="at">:name</span> <span class="st">&quot;China Miéville&quot;</span>, <span class="at">:birth-year</span> <span class="dv">1972</span>})</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> octavia </span>{<span class="at">:name</span> <span class="st">&quot;Octavia E. Butler&quot;</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>              <span class="at">:birth-year</span> <span class="dv">1947</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>              <span class="at">:death-year</span> <span class="dv">2006</span>})</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> friedman </span>{<span class="at">:name</span> <span class="st">&quot;Daniel Friedman&quot;</span> <span class="at">:birth-year</span> <span class="dv">1944</span>})</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> felleisen </span>{<span class="at">:name</span> <span class="st">&quot;Matthias Felleisen&quot;</span>})</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> cities </span>{<span class="at">:title</span> <span class="st">&quot;The City and the City&quot;</span> <span class="at">:authors</span> [china]})</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> wild-seed </span>{<span class="at">:title</span> <span class="st">&quot;Wild Seed&quot;</span>, <span class="at">:authors</span> [octavia]})</span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> embassytown </span>{<span class="at">:title</span> <span class="st">&quot;Embassytown&quot;</span>, <span class="at">:authors</span> [china]})</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> little-schemer </span>{<span class="at">:title</span> <span class="st">&quot;The Little Schemer&quot;</span></span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true" tabindex="-1"></a>                     <span class="at">:authors</span> [friedman, felleisen]})</span></code></pre></div>
<section class="alert alert-success">
<h3>
Exercise 10
</h3>
<p>Write the function <code>(title-length book)</code> that counts the
length of the book’s title.</p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>(title-length cities)         <span class="co">;=&gt; 21</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>(title-length wild-seed)      <span class="co">;=&gt; 9</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>(title-length little-schemer) <span class="co">;=&gt; 18</span></span></code></pre></div>
</section>
<section class="alert alert-success">
<h3>
Exercise 11
</h3>
<p>Write the function <code>(author-count book)</code> that returns the
amount of authors that <code>book</code> has.</p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>(author-count cities)         <span class="co">;=&gt; 1</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a>(author-count wild-seed)      <span class="co">;=&gt; 1</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>(author-count little-schemer) <span class="co">;=&gt; 2</span></span></code></pre></div>
</section>
<section class="alert alert-success">
<h3>
Exercise 12
</h3>
<p>Write the function <code>(multiple-authors? book)</code> that returns
<code>true</code> if <code>book</code> has multiple authors, otherwise
<code>false</code>.</p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>(multiple-authors? cities)         <span class="co">;=&gt; false</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a>(multiple-authors? wild-seed)      <span class="co">;=&gt; false</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>(multiple-authors? little-schemer) <span class="co">;=&gt; true</span></span></code></pre></div>
</section>
</section>
<section id="adding-values-to-a-map" class="level3">
<h3>Adding Values to a Map</h3>
<p><code>(assoc a-map a-key a-value)</code> sets the value of
<code>a-key</code> in <code>a-map</code> to be <code>a-value</code>.</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">assoc</span> {<span class="at">:a</span> <span class="dv">1</span>} <span class="at">:b</span> <span class="dv">2</span>) <span class="co">;=&gt; {:b 2, :a 1}</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">assoc</span> {<span class="at">:a</span> <span class="dv">1</span>} <span class="at">:a</span> <span class="dv">2</span>) <span class="co">;=&gt; {:a 2}</span></span></code></pre></div>
<p>Let’s add some information to a book:</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">assoc</span> cities <span class="at">:awards</span> [<span class="st">&quot;Hugo&quot;</span>, <span class="st">&quot;World Fantasy Award&quot;</span>,</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>                       <span class="st">&quot;Arthur C. Clarke Award&quot;</span>,</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a>                       <span class="st">&quot;British Science Fiction Award&quot;</span>])</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; {:awards [&quot;Hugo&quot; &quot;World Fantasy Award&quot; &quot;Arthur C. Clarke Award&quot;</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="co">;             &quot;British Science Fiction Award&quot;]</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a><span class="co">;    :title &quot;The City and the City&quot;</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a><span class="co">;    :authors [{:birth-year 1972, :name &quot;China Miéville&quot;}]}</span></span></code></pre></div>
<p>Vectors are an associative data structure, so <code>assoc</code> also
works with them.</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co">;index: 0 1 2                0   1   2</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">assoc</span> [<span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span>] <span class="dv">1</span> <span class="st">&quot;~o~&quot;</span>) <span class="co">;=&gt; [3 &quot;~o~&quot; 1]</span></span></code></pre></div>
<p>Here the key that you give as a parameter is the index that you want
to change.</p>
<p>Assoc does not actually change the original data structure, but
instead returns an updated version of it.</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> [original [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>      new      (<span class="kw">assoc</span> original <span class="dv">2</span> <span class="st">&quot;foo&quot;</span>)]</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  original)</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; [1 2 3 4]</span></span></code></pre></div>
<section class="alert alert-success">
<h3>
Exercise 13
</h3>
<p>Use <code>assoc</code> and <code>conj</code> to write the function
<code>(add-author book new-author)</code> that takes a book and an
author as a parameter and adds <code>author</code> to <code>book</code>s
authors.</p>
<p>Hint: use <code>let</code> to avoid pain</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>(add-author little-schemer {<span class="at">:name</span> <span class="st">&quot;Gerald J. Sussman&quot;</span>})</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; {:title &quot;The Little Schemer&quot;</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="co">;    :authors [{:birth-year 1944, :name &quot;Daniel Friedman&quot;}</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a><span class="co">;              {:name &quot;Matthias Felleisen&quot;}</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a><span class="co">;              {:name &quot;Gerald J. Sussman&quot;}]}</span></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>(add-author {<span class="at">:authors</span> [{<span class="at">:name</span> <span class="st">&quot;Juhana&quot;</span>}]} {<span class="at">:name</span> <span class="st">&quot;Jani&quot;</span>})</span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; {:authors [{:name &quot;Juhana&quot;} {:name &quot;Jani&quot;}]}</span></span></code></pre></div>
</section>
<p>The keys and values of a map can be of any data type, and one map can
contain any number of different data types as both keys and values.</p>
<p><code>(contains? a-map a-key)</code> can be used to check if
<code>a-map</code> has a value for <code>a-key</code>.</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">contains?</span> {<span class="st">&quot;a&quot;</span> <span class="dv">1</span>} <span class="st">&quot;a&quot;</span>)   <span class="co">;=&gt; true</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">contains?</span> {<span class="st">&quot;a&quot;</span> <span class="dv">1</span>} <span class="dv">1</span>)     <span class="co">;=&gt; false</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">contains?</span> {<span class="st">&quot;a&quot;</span> <span class="va">nil</span>} <span class="st">&quot;a&quot;</span>) <span class="co">;=&gt; true</span></span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">contains?</span> cities <span class="at">:title</span>) <span class="co">;=&gt; true</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>(<span class="kw">contains?</span> cities <span class="at">:name</span>)  <span class="co">;=&gt; false</span></span></code></pre></div>
<section class="alert alert-success">
<h3>
Exercise 14
</h3>
<p>Write the function <code>(alive? author)</code> which takes an author
map and returns <code>true</code> if the <code>author</code> is alive,
otherwise <code>false</code>.</p>
<p>An author is alive if the author does not have a death year.</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>(alive? china)   <span class="co">;=&gt; true</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>(alive? octavia) <span class="co">;=&gt; false</span></span></code></pre></div>
</section>
</section>
</section>
<section id="serial-grave-digging" class="level2">
<h2>Serial grave digging</h2>
<p>We know how to extract information from a single book or author.
However, we often want to extract information from a collection of
items. As an example, given a collection of books, we want the names of
all the authors:</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> books </span>[cities, wild-seed, embassytown, little-schemer])</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>(all-author-names books)</span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; #{&quot;China Miéville&quot; &quot;Octavia E. Butler&quot;</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a><span class="co">;     &quot;Daniel Friedman&quot; &quot;Matthias Felleisen&quot;}</span></span></code></pre></div>
<p>How should we implement <code>all-author-names</code>?</p>
<p>We’ll give the implementation now, and introduce the new concepts
used one by one. The implementation looks like this:</p>
<div class="sourceCode" id="cb42"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> author-names </span>[book]</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">map</span> <span class="at">:name</span> (<span class="at">:authors</span> book)))</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> all-author-names </span>[books]</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">set</span> (<span class="kw">apply</span> <span class="kw">concat</span> (<span class="kw">map</span> author-names books))))</span></code></pre></div>
<p>Now there’s a lot of new stuff there, so we’ll take a detour to learn
it all before continuing with our book library.</p>
<p>Let’s take a look at this <code>map</code> function.</p>
<section id="sequences" class="level3">
<h3>Sequences</h3>
<p>Before talking about <code>map</code>, we need to introduce a new
concept: the <em>sequence</em>. Many of Clojure’s functions that operate
on vectors and other collections actually operate on sequences. The
<code>(seq collection)</code> function returns a sequence constructed
from a collection, such as a vector or a map.</p>
<p>Sequences have the following operations:</p>
<ul>
<li><p><code>(first sequence)</code> returns the first element of the
sequence.</p></li>
<li><p><code>(rest sequence)</code> returns the sequence without its
first element.</p></li>
<li><p><code>(cons item sequence)</code> returns a new sequence where
<code>item</code> is the first element and <code>sequence</code> is the
rest.</p></li>
</ul>
<div class="sourceCode" id="cb43"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">seq</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])          <span class="co">;=&gt; (1 2 3)</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">seq</span> {<span class="at">:a</span> <span class="dv">42</span> <span class="at">:b</span> <span class="st">&quot;foo&quot;</span> <span class="at">:c</span> [<span class="st">&quot;ur&quot;</span> <span class="st">&quot;dad&quot;</span>]})</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>                       <span class="co">;=&gt; ([:a 42] [:c [&quot;ur&quot; &quot;dad&quot;]] [:b &quot;foo&quot;])</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">first</span> (<span class="kw">seq</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]))  <span class="co">;=&gt; 1</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>(<span class="kw">rest</span> (<span class="kw">seq</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>))    <span class="co">;=&gt; (2 3)</span></span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a>(<span class="kw">cons</span> <span class="dv">0</span> (<span class="kw">seq</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])) <span class="co">;=&gt; (0 1 2 3)</span></span></code></pre></div>
<p>Here you can see the printed form of sequences, the elements inside
<code>(</code> and <code>)</code>. This has the consequence that copying
<code>(1 2 3)</code> back to the REPL tries to call <code>1</code> as a
function. The result is that you can not use the printed form of a
sequence as a value like you could with vectors and maps.</p>
<p>Actually, the sequence functions call <code>seq</code> on their
collection parameters themselves, so we can just write the above
examples like this:</p>
<div class="sourceCode" id="cb44"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">first</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])  <span class="co">;=&gt; 1</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">rest</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])   <span class="co">;=&gt; (2 3)</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">cons</span> <span class="dv">0</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>]) <span class="co">;=&gt; (0 1 2 3)</span></span></code></pre></div>
</section>
<section id="the-map-function" class="level3">
<h3>The map function</h3>
<p><code>(map function collection)</code> takes two parameters, a
function and a sequenceable collection. It calls the function on each
element of the sequence and returns a sequence of the return values.</p>
<div class="sourceCode" id="cb45"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> munge </span>[x]</span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">+</span> x <span class="dv">42</span>))</span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">map</span> munge [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>])</span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; ((munge 1) (munge 2) (munge 3) (munge 4)) ; [note below]</span></span>
<span id="cb45-6"><a href="#cb45-6" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; ( 43        44        45        46)</span></span></code></pre></div>
<p><em>Note:</em> You can’t paste the result line (or the middle one) to
the REPL, as it is the printed form of a sequence.</p>
<section class="alert alert-success">
<h3>
Exercise 15
</h3>
<p>Write the function <code>(element-lengths collection)</code> that
returns the lengths of every item in <code>collection</code>.</p>
<div class="sourceCode" id="cb46"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>(element-lengths [<span class="st">&quot;foo&quot;</span> <span class="st">&quot;bar&quot;</span> <span class="st">&quot;&quot;</span> <span class="st">&quot;quux&quot;</span>])  <span class="co">;=&gt; (3 3 0 4)</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>(element-lengths [<span class="st">&quot;x&quot;</span> [<span class="at">:a</span> <span class="at">:b</span> <span class="at">:c</span>] {<span class="at">:y</span> <span class="dv">42</span>}]) <span class="co">;=&gt; (1 3 1)</span></span></code></pre></div>
</section>
<p>Earlier, we briefly introduces the <code>fn</code> special form that
can be used to create functions. This is useful when you want a function
that is only visible in the definition of another function. Quite often
you want to use <code>let</code> to give name to this helper
function.</p>
<p>Let’s rewrite the example above in this style:</p>
<div class="sourceCode" id="cb47"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> mungefy </span>[a-seq]</span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> [munge (<span class="kw">fn</span> [x] (<span class="kw">+</span> x <span class="dv">42</span>))]</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">map</span> munge a-seq)))</span></code></pre></div>
<p>Now the function <code>munge</code> is only visible inside the
definition of <code>mungefy</code>. It should work like the previous
one.</p>
<div class="sourceCode" id="cb48"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>(mungefy [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>]) <span class="co">;=&gt; (43 44 45 46)</span></span></code></pre></div>
<section class="alert alert-success">
<h3>
Exercise 16
</h3>
<p>Use <code>map</code> to write the function
<code>(second-elements collection)</code> that takes a vector of vectors
and returns a sequence of the second elements.</p>
<p>Remember that you can use <code>get</code> to index a vector.</p>
<p>Use <code>fn</code> and <code>let</code> to create a helper function
and use it with <code>map</code>.</p>
<div class="sourceCode" id="cb49"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>(second-elements [[<span class="dv">1</span> <span class="dv">2</span>] [<span class="dv">2</span> <span class="dv">3</span>] [<span class="dv">3</span> <span class="dv">4</span>]]) <span class="co">;=&gt; (2 3 4)</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>(second-elements [[<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>] [<span class="dv">1</span>] [<span class="st">&quot;a&quot;</span> <span class="st">&quot;s&quot;</span> <span class="st">&quot;d&quot;</span> <span class="st">&quot;f&quot;</span>]])</span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; (2 nil &quot;s&quot;)</span></span></code></pre></div>
</section>
<p>When you have a sequence of maps, the fact that
<code>:keywords</code> are also functions can be helpful.</p>
<div class="sourceCode" id="cb50"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>(<span class="at">:name</span> {<span class="at">:name</span> <span class="st">&quot;MEEEE&quot;</span>, <span class="at">:secret</span> <span class="st">&quot;Awesome&quot;</span>}) <span class="co">;=&gt;  &quot;MEEEE&quot;</span></span></code></pre></div>
<p>You can therefore use a <code>:keyword</code> as the function
parameter of <code>map</code>.</p>
<div class="sourceCode" id="cb51"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">let</span> [people [{<span class="at">:name</span> <span class="st">&quot;Juhana&quot;</span>, <span class="at">:age</span> <span class="dv">3</span>}</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>              {<span class="at">:name</span> <span class="st">&quot;Ilmari&quot;</span>, <span class="at">:age</span> <span class="dv">42</span>}</span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>              {<span class="at">:name</span> <span class="st">&quot;Jani&quot;</span>, <span class="at">:age</span> <span class="dv">72</span>}</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>              {<span class="at">:name</span> <span class="st">&quot;King of All Cosmos&quot;</span> <span class="at">:age</span> -<span class="dv">6</span>}]]</span>
<span id="cb51-5"><a href="#cb51-5" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">map</span> <span class="at">:age</span> people))</span>
<span id="cb51-6"><a href="#cb51-6" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; (3 42 72 -6)</span></span></code></pre></div>
<section class="alert alert-success">
<h3>
Exercise 17
</h3>
<p>Write the function <code>(titles books)</code> that takes a
collection of books and returns their titles.</p>
<p>Using our earlier examples:</p>
<div class="sourceCode" id="cb52"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> china </span>{<span class="at">:name</span> <span class="st">&quot;China Miéville&quot;</span>, <span class="at">:birth-year</span> <span class="dv">1972</span>})</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> octavia </span>{<span class="at">:name</span> <span class="st">&quot;Octavia E. Butler&quot;</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>              <span class="at">:birth-year</span> <span class="dv">1947</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a>              <span class="at">:death-year</span> <span class="dv">2006</span>})</span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> friedman </span>{<span class="at">:name</span> <span class="st">&quot;Daniel Friedman&quot;</span> <span class="at">:birth-year</span> <span class="dv">1944</span>})</span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> felleisen </span>{<span class="at">:name</span> <span class="st">&quot;Matthias Felleisen&quot;</span>})</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> cities </span>{<span class="at">:title</span> <span class="st">&quot;The City and the City&quot;</span> <span class="at">:authors</span> [china]})</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> wild-seed </span>{<span class="at">:title</span> <span class="st">&quot;Wild Seed&quot;</span>, <span class="at">:authors</span> [octavia]})</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> embassytown </span>{<span class="at">:title</span> <span class="st">&quot;Embassytown&quot;</span>, <span class="at">:authors</span> [china]})</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> little-schemer </span>{<span class="at">:title</span> <span class="st">&quot;The Little Schemer&quot;</span></span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>                     <span class="at">:authors</span> [friedman, felleisen]})</span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> books </span>[cities, wild-seed, embassytown, little-schemer])</span></code></pre></div>
<p><code>titles</code> should work like this:</p>
<pre><code>(titles [cities]) ;=&gt; (&quot;The City and the City&quot; )
(titles books)
;=&gt; (&quot;The City and the City&quot; &quot;Wild Seed&quot;
;    &quot;Embassytown&quot; &quot;The Little Schemer&quot;)</code></pre>
</section>
<p>Okey, so now that <code>map</code> has been gone over, let’s see the
definition of <code>all-author-names</code> again.</p>
<div class="sourceCode" id="cb54"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> author-names </span>[book]</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">map</span> <span class="at">:name</span> (<span class="at">:authors</span> book)))</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> all-author-names </span>[books]</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">set</span> (<span class="kw">apply</span> <span class="kw">concat</span> (<span class="kw">map</span> author-name books))))</span></code></pre></div>
<p><code>author-names</code> returns the names of the authors of a
single book.</p>
<div class="sourceCode" id="cb55"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>(author-names cities)         <span class="co">;=&gt; (&quot;China Miéville&quot;)</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>(author-names little-schemer) <span class="co">;=&gt; (&quot;Daniel Friedman&quot; &quot;Matthias Felleisen&quot;)</span></span></code></pre></div>
<p>Since this is just a helper function used inside
<code>all-author-names</code> we can move it inside by using
<code>let</code> and <code>fn</code>.</p>
<div class="sourceCode" id="cb56"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> all-author-names </span>[books]</span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> [author-names</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>         (<span class="kw">fn</span> [book] (<span class="kw">map</span> <span class="at">:name</span> (<span class="at">:authors</span> book)))]</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">set</span> (<span class="kw">apply</span> <span class="kw">concat</span> (<span class="kw">map</span> author-names books)))))</span></code></pre></div>
<p>The definition of <code>all-author-names</code> still has some
mysterious words like <code>set</code>, <code>apply</code> and
<code>concat</code> in it. Let’s see what would happen without them.</p>
<div class="sourceCode" id="cb57"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">map</span> author-names [cities]) <span class="co">;=&gt; ((&quot;China Miéville&quot;))</span></span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">map</span> author-names [cities, wild-seed]) <span class="co">;=&gt; ((&quot;China Miéville&quot;) (&quot;Octavia E. Butler&quot;))</span></span></code></pre></div>
<p>So first of all we would get every books authors inside a sequence.
To fix this, we need to concatenate the sequences. To do this, there is
<code>concat</code>.</p>
<div class="sourceCode" id="cb58"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">concat</span> [<span class="st">&quot;China Miéville&quot;</span>] [<span class="st">&quot;Octavia E. Butler&quot;</span>]) <span class="co">;=&gt; (&quot;China Miéville&quot; &quot;Octavia E. Butler&quot;)</span></span></code></pre></div>
<p>This looks like what we want. However, if we simply try to use
<code>(concat (map author-names books))</code>, we get the following
problem:</p>
<div class="sourceCode" id="cb59"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">concat</span> (<span class="kw">map</span> author-names [cities, wild-seed]))</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; (concat ((&quot;China Miéville&quot;) (&quot;Octavia E. Butler&quot;)))</span></span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; ((&quot;China Miéville&quot;) (&quot;Octavia E. Butler&quot;))</span></span></code></pre></div>
<p>So we end up only giving <code>concat</code> one argument and it
simply returns the argument. What we want is to give the elements of
<code>(map author-names books)</code> to <code>concat</code> as
arguments.</p>
<p>No worries, there is a way to do this. Let’s check out
<code>apply</code>.</p>
</section>
<section id="apply-now-redux" class="level3">
<h3>Apply Now, Redux</h3>
<p><code>(apply function a-seq)</code> applies <code>function</code> to
the arguments in <code>a-seq</code>. Here’s an example:</p>
<div class="sourceCode" id="cb60"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">apply</span> <span class="kw">+</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; (+ 1 2 3)</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; 6</span></span></code></pre></div>
<p>And here’s another with <code>concat</code>:</p>
<div class="sourceCode" id="cb61"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">apply</span> <span class="kw">concat</span> [[<span class="st">&quot;China Miéville&quot;</span>] [<span class="st">&quot;Octavia E. Butler&quot;</span>]])</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; (concat [&quot;China Miéville&quot;] [&quot;Octavia E. Butler&quot;])</span></span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; (&quot;China Miéville&quot; &quot;Octavia E. Butler&quot;)</span></span></code></pre></div>
<p>More generally, <code>apply</code> works like this:</p>
<div class="sourceCode" id="cb62"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">apply</span> function [arg1 arg2 arg3 ...]) =&gt; (function arg1 arg2 arg3 ...)</span></code></pre></div>
<section class="alert alert-success">
<h3>
Exercise 18
</h3>
<p>Write the function <code>(stars n)</code> that returns a string with
<code>n</code> aterisks <code>\*</code>.</p>
<p>The function <code>(repeat n x)</code> returns a sequence with
<code>n</code> <code>x</code>s:</p>
<div class="sourceCode" id="cb63"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">repeat</span> <span class="dv">5</span> <span class="st">&quot;*&quot;</span>) <span class="co">;=&gt; (&quot;*&quot; &quot;*&quot; &quot;*&quot; &quot;*&quot; &quot;*&quot;)</span></span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">repeat</span> <span class="dv">3</span> <span class="st">&quot;~o~&quot;</span>) <span class="co">;=&gt; (&quot;~o~&quot; &quot;~o~&quot; &quot;~o~&quot;)</span></span></code></pre></div>
<p>Remember that you can use <code>str</code> to concatenate
strings.</p>
<div class="sourceCode" id="cb64"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>(stars <span class="dv">1</span>) <span class="co">;=&gt; &quot;*&quot;</span></span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>(stars <span class="dv">7</span>) <span class="co">;=&gt; &quot;*******&quot;</span></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a>(stars <span class="dv">3</span>) <span class="co">;=&gt; &quot;***&quot;</span></span></code></pre></div>
<!-- ********* -->
</section>
<section class="alert alert-success">
<h3>
Exercise 19
</h3>
<p>Write the function <code>(monotonic? a-seq)</code> that returns
<code>true</code> if <code>a-seq</code> is monotonic and otherwise
<code>false</code>.</p>
<p>A sequence is monotonic if is either inceasing or decreasing. In a
decreasing sequence every element is at most as large as the previous
one and in an increasing sequence every member is at least as large as
the previous one.</p>
<p>Use <code>apply</code>.</p>
<p>Hint: <code>&lt;=</code> might be useful</p>
<div class="sourceCode" id="cb65"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a>(monotonic? [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])     <span class="co">;=&gt; true</span></span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a>(monotonic? [<span class="dv">0</span> <span class="dv">1</span> <span class="dv">10</span> <span class="dv">11</span>]) <span class="co">;=&gt; true</span></span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a>(monotonic? [<span class="dv">3</span> <span class="dv">2</span> <span class="dv">0</span> -<span class="dv">3</span>])  <span class="co">;=&gt; true</span></span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a>(monotonic? [<span class="dv">3</span> <span class="dv">2</span> <span class="dv">2</span>])     <span class="co">;=&gt; true    Not strictly monotonic</span></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a>(monotonic? [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">1</span> <span class="dv">0</span>])   <span class="co">;=&gt; false</span></span></code></pre></div>
</section>
<p>So now we can put all authors into a single list. There’s just one
problem left. What is that? Well, let’s see what happens if we put
together everything seen so far.</p>
<div class="sourceCode" id="cb66"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">apply</span> <span class="kw">concat</span> (<span class="kw">map</span> author-names books))</span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; (&quot;China Miéville&quot; &quot;Octavia E. Butler&quot;</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="co">;    &quot;China Miéville&quot; &quot;Daniel Friedman&quot;</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="co">;    &quot;Matthias Felleisen&quot;)</span></span></code></pre></div>
<p>We had two books by China Miéville, so his name is in the resulting
sequence twice. But when we want to see the authors, we are usually not
interested in duplicates. So lets turn the sequence into a data
structure that supports this.</p>
</section>
<section id="set" class="level3">
<h3>Set</h3>
<p>Our last major data structure is the set. It is an unordered
collection of items without duplicates.</p>
<div class="sourceCode" id="cb67"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">set</span> [<span class="st">&quot;^^&quot;</span> <span class="st">&quot;^^&quot;</span> <span class="st">&quot;^__*__^&quot;</span>]) <span class="co">;=&gt; #{&quot;^__*__^&quot; &quot;^^&quot;}</span></span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">set</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">1</span> <span class="dv">3</span> <span class="dv">3</span> <span class="dv">2</span> <span class="dv">1</span>]) <span class="co">;=&gt; #{1 2 3}</span></span></code></pre></div>
<p>The textual form of a set is <code>#{an-elem another-elem ...}</code>
and you can convert another collection into a set with the function
<code>set</code>.</p>
<p>Sets have three basic operations:</p>
<p>You can check whether a set contains an element with the function
<code>contains?</code>:</p>
<div class="sourceCode" id="cb68"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> games </span>#{<span class="st">&quot;Portal&quot;</span>, <span class="st">&quot;Planescape: Torment&quot;</span>,</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>             <span class="st">&quot;Machinarium&quot;</span>, <span class="st">&quot;Alpha Protocol&quot;</span>})</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">contains?</span> games <span class="st">&quot;Portal&quot;</span>) <span class="co">;=&gt; true</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>(<span class="kw">contains?</span> games <span class="st">&quot;RAGE&quot;</span>)   <span class="co">;=&gt; false</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a>(<span class="kw">contains?</span> games <span class="dv">42</span>)       <span class="co">;=&gt; false</span></span></code></pre></div>
<p><code>(conj set elem)</code> adds elem to <code>set</code> if it does
not already have <code>elem</code>:</p>
<div class="sourceCode" id="cb69"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">conj</span> #{<span class="at">:a</span> <span class="at">:b</span> <span class="at">:c</span>} <span class="at">:EEEEE</span>) <span class="co">;=&gt; #{:a :c :b :EEEEE}</span></span></code></pre></div>
<p>Nothing happens if <code>elem</code> is already a member of
<code>set</code>:</p>
<div class="sourceCode" id="cb70"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">conj</span> #{<span class="at">:a</span> <span class="at">:b</span> <span class="at">:c</span>} <span class="at">:a</span>)     <span class="co">;=&gt; #{:a :c :b}</span></span></code></pre></div>
<p>You can also add multiple elements by giving <code>conj</code>
additional arguments:</p>
<div class="sourceCode" id="cb71"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">conj</span> #{<span class="at">:a</span> <span class="at">:b</span> <span class="at">:c</span>} <span class="at">:d</span> <span class="at">:e</span>)  <span class="co">;=&gt; #{:a :c :b :d :e}</span></span></code></pre></div>
<p>Finally, <code>(disj set elem)</code> removes <code>elem</code> from
<code>set</code> if it contains <code>elem</code>:</p>
<div class="sourceCode" id="cb72"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">disj</span> #{<span class="at">:a</span> <span class="at">:b</span> <span class="at">:c</span>} <span class="at">:c</span>) <span class="co">;=&gt; #{:a :b}</span></span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">disj</span> #{<span class="at">:a</span> <span class="at">:b</span> <span class="at">:c</span>} <span class="at">:EEEEE</span>) <span class="co">;=&gt; #{:a :c :b}</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">disj</span> #{<span class="at">:a</span> <span class="at">:b</span> <span class="at">:c</span>} <span class="at">:c</span> <span class="at">:a</span>) <span class="co">;=&gt; #{:b}</span></span></code></pre></div>
<p><a id="toggle"></a></p>
<section class="alert alert-success">
<h3>
Exercise 20
</h3>
<p>Write the function <code>(toggle a-set elem)</code> that removes
<code>elem</code> from <code>a-set</code> if <code>a-set</code> contains
<code>elem</code>, and adds it to the set otherwise.</p>
<div class="sourceCode" id="cb73"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>(toggle #{<span class="at">:a</span> <span class="at">:b</span> <span class="at">:c</span>} <span class="at">:d</span>) <span class="co">;=&gt; #{:a :c :b :d}</span></span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>(toggle #{<span class="at">:a</span> <span class="at">:b</span> <span class="at">:c</span>} <span class="at">:a</span>) <span class="co">;=&gt; #{:c :b}</span></span></code></pre></div>
</section>
<p>If you want to know the size of a set, <code>count</code> also works
with sets.</p>
<div class="sourceCode" id="cb74"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">count</span> #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>}) <span class="co">;=&gt; 3</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">count</span> (<span class="kw">set</span> [<span class="dv">1</span> <span class="dv">2</span>])) <span class="co">;=&gt; 2</span></span></code></pre></div>
<section class="alert alert-success">
<h3>
Exercise 21
</h3>
<p>Write the function <code>(contains-duplicates? sequence)</code> that
takes a sequence as a parameter and returns <code>true</code> if
<code>sequence</code> contains some element multiple times. Otherwise it
returns <code>false</code>.</p>
<div class="sourceCode" id="cb75"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a>(contains-duplicates? [<span class="dv">1</span> <span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> -<span class="dv">40</span>]) <span class="co">;=&gt; true</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>(contains-duplicates? [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> -<span class="dv">40</span>]) <span class="co">;=&gt; false</span></span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>(contains-duplicates? [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="st">&quot;a&quot;</span> <span class="st">&quot;a&quot;</span>]) <span class="co">;=&gt; true</span></span></code></pre></div>
</section>
<p>Our books looked like this:</p>
<div class="sourceCode" id="cb76"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb76-1"><a href="#cb76-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> friedman </span>{<span class="at">:name</span> <span class="st">&quot;Daniel Friedman&quot;</span> <span class="at">:birth-year</span> <span class="dv">1944</span>})</span>
<span id="cb76-2"><a href="#cb76-2" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> felleisen </span>{<span class="at">:name</span> <span class="st">&quot;Matthias Felleisen&quot;</span>})</span>
<span id="cb76-3"><a href="#cb76-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb76-4"><a href="#cb76-4" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> little-schemer </span>{<span class="at">:title</span> <span class="st">&quot;The Little Schemer&quot;</span></span>
<span id="cb76-5"><a href="#cb76-5" aria-hidden="true" tabindex="-1"></a>                     <span class="at">:authors</span> [friedman, felleisen]})</span></code></pre></div>
<p>Now we can understand the whole implementation of
<code>all-author-names</code>. We use</p>
<ul>
<li><code>fn</code> to introduce a helper function,</li>
<li>keywords to index the books,</li>
<li>map to get all authors from a single book</li>
<li><code>let</code> to give a name to our helper function,</li>
<li><code>map</code> to apply the helper function to all the given
books, and</li>
<li>construct a set with the <code>set</code> function to get rid of
duplicates.</li>
</ul>
<div class="sourceCode" id="cb77"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> all-author-names </span>[books]</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> [author-names</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a>         (<span class="kw">fn</span> [book] (<span class="kw">map</span> <span class="at">:name</span> (<span class="at">:authors</span> book)))]</span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">set</span> (<span class="kw">apply</span> <span class="kw">concat</span> (<span class="kw">map</span> author-names books)))))</span></code></pre></div>
<p>Calling our function returns the desired set:</p>
<div class="sourceCode" id="cb78"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a>(all-author-names books)</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; #{&quot;Matthias Felleisen&quot; &quot;China Miéville&quot;</span></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a><span class="co">;     &quot;Octavia E. Butler&quot; &quot;Daniel Friedman&quot;}</span></span></code></pre></div>
</section>
</section>
<section id="representing-books-take-two" class="level2">
<h2>Representing Books, Take Two</h2>
<p>Now I would like to ask whether <code>little-schemer</code> has
<code>felleisen</code> as an author or not. This turns out to be
problematic. There is no function on vectors that can be used to query
membership. So how about we change the representation of books? We now
have a motivation to put authors into a set instead of a vector. This
feels like a more natural fit, since a book never has a single author
multiple times and our data doesn’t give a natural order for the
authors.</p>
<p>New representation:</p>
<div class="sourceCode" id="cb79"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> little-schemer </span>{<span class="at">:title</span> <span class="st">&quot;The Little Schemer&quot;</span></span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>                     <span class="at">:authors</span> #{friedman, felleisen}})</span></code></pre></div>
<section class="alert alert-success">
<h3>
Exercise 22
</h3>
<p>Write the function <code>(old-book-&gt;new-book book)</code> that
takes a book with the previous representation (authors in a vector) and
returns the same book in the new representation (authors in a set).</p>
<p>Use <code>assoc</code> to change the representation. Do not construct
a new map using the map literal syntax.</p>
<div class="sourceCode" id="cb80"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>(old-book-&gt;new-book {<span class="at">:title</span> <span class="st">&quot;The Little Schemer&quot;</span></span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>                     <span class="at">:authors</span> [friedman, felleisen]})</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; {:title &quot;The Little Schemer&quot; :authors #{friedman, felleisen}}</span></span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>(old-book-&gt;new-book {<span class="at">:title</span> <span class="st">&quot;Wild Seed&quot;</span>, <span class="at">:authors</span> [octavia]})</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; {:title &quot;Wild Seed&quot;, :authors #{octavia}}</span></span></code></pre></div>
<p>The reason to use <code>assoc</code> is that it allows us to keep any
additional key-value pairs intact. Earlier we had an example where we
added a list of awards to a book. By using <code>assoc</code>, these
additional key-value pairs do not disappear anywhere during the
transformation.</p>
<div class="sourceCode" id="cb81"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>(old-book-&gt;new-book</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a>  {<span class="at">:awards</span> [<span class="st">&quot;Hugo&quot;</span> <span class="st">&quot;World Fantasy Award&quot;</span> <span class="st">&quot;Arthur C. Clarke Award&quot;</span></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;British Science Fiction Award&quot;</span>]</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>   <span class="at">:title</span> <span class="st">&quot;The City and the City&quot;</span></span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>   <span class="at">:authors</span> [{<span class="at">:birth-year</span> <span class="dv">1972</span>, <span class="at">:name</span> <span class="st">&quot;China Miéville&quot;</span>}]})</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; {:awards [&quot;Hugo&quot; &quot;World Fantasy Award&quot; &quot;Arthur C. Clarke Award&quot;</span></span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a><span class="co">;             &quot;British Science Fiction Award&quot;]</span></span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a><span class="co">;    :title &quot;The City and the City&quot;</span></span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a><span class="co">;    :authors #{{:birth-year 1972, :name &quot;China Miéville&quot;</span><span class="re">}}}</span></span></code></pre></div>
</section>
<p>Here are all of the books changed to the new representation:</p>
<div class="sourceCode" id="cb82"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> china </span>{<span class="at">:name</span> <span class="st">&quot;China Miéville&quot;</span>, <span class="at">:birth-year</span> <span class="dv">1972</span>})</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> octavia </span>{<span class="at">:name</span> <span class="st">&quot;Octavia E. Butler&quot;</span></span>
<span id="cb82-3"><a href="#cb82-3" aria-hidden="true" tabindex="-1"></a>              <span class="at">:birth-year</span> <span class="dv">1947</span></span>
<span id="cb82-4"><a href="#cb82-4" aria-hidden="true" tabindex="-1"></a>              <span class="at">:death-year</span> <span class="dv">2006</span>})</span>
<span id="cb82-5"><a href="#cb82-5" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> friedman </span>{<span class="at">:name</span> <span class="st">&quot;Daniel Friedman&quot;</span> <span class="at">:birth-year</span> <span class="dv">1944</span>})</span>
<span id="cb82-6"><a href="#cb82-6" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> felleisen </span>{<span class="at">:name</span> <span class="st">&quot;Matthias Felleisen&quot;</span>})</span>
<span id="cb82-7"><a href="#cb82-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-8"><a href="#cb82-8" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> cities </span>{<span class="at">:title</span> <span class="st">&quot;The City and the City&quot;</span> <span class="at">:authors</span> #{china}})</span>
<span id="cb82-9"><a href="#cb82-9" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> wild-seed </span>{<span class="at">:title</span> <span class="st">&quot;Wild Seed&quot;</span>, <span class="at">:authors</span> #{octavia}})</span>
<span id="cb82-10"><a href="#cb82-10" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> embassytown </span>{<span class="at">:title</span> <span class="st">&quot;Embassytown&quot;</span>, <span class="at">:authors</span> #{china}})</span>
<span id="cb82-11"><a href="#cb82-11" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> little-schemer </span>{<span class="at">:title</span> <span class="st">&quot;The Little Schemer&quot;</span></span>
<span id="cb82-12"><a href="#cb82-12" aria-hidden="true" tabindex="-1"></a>                     <span class="at">:authors</span> #{friedman, felleisen}})</span>
<span id="cb82-13"><a href="#cb82-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb82-14"><a href="#cb82-14" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> books </span>[cities, wild-seed, embassytown, little-schemer])</span></code></pre></div>
<p>Now that the authors are in a set, it is easy to find out whether a
book has some author or not.</p>
<section class="alert alert-success">
<h3>
Exercise 23
</h3>
<p>Write the function <code>(has-author? book author)</code> that
returns <code>true</code> if <code>author</code> is in the authors of
<code>book</code> and otherwise <code>false</code>.</p>
<div class="sourceCode" id="cb83"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>(has-author? cities china)             <span class="co">;=&gt; true</span></span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>(has-author? cities felleisen)         <span class="co">;=&gt; false</span></span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>(has-author? little-schemer felleisen) <span class="co">;=&gt; true</span></span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a>(has-author? little-schemer friedman)  <span class="co">;=&gt; true</span></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>(has-author? little-schemer octavia)   <span class="co">;=&gt; false</span></span></code></pre></div>
</section>
<p>Does our previous definition for <code>all-author-names</code> still
work? It does, but let’s take another look at it.</p>
<div class="sourceCode" id="cb84"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb84-1"><a href="#cb84-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">defn</span><span class="fu"> all-author-names </span>[books]</span>
<span id="cb84-2"><a href="#cb84-2" aria-hidden="true" tabindex="-1"></a>  (<span class="kw">let</span> [author-names</span>
<span id="cb84-3"><a href="#cb84-3" aria-hidden="true" tabindex="-1"></a>         (<span class="kw">fn</span> [book] (<span class="kw">map</span> <span class="at">:name</span> (<span class="at">:authors</span> book)))]</span>
<span id="cb84-4"><a href="#cb84-4" aria-hidden="true" tabindex="-1"></a>    (<span class="kw">set</span> (<span class="kw">apply</span> <span class="kw">concat</span> (<span class="kw">map</span> author-names books)))))</span></code></pre></div>
<p>Here we first turn each book into a sequence of names. Concatenate
the sequences and finally turn this sequence into a set. Let’s break
this into two steps. First, let’s define a function that returns all
authors in a set. Then use this set to get the names.</p>
<p>For sets, there is a special function
<code>(clojure.set/union set1 set2 ...)</code> that returns a new set
that has all the elements of its parameters.</p>
<div class="sourceCode" id="cb85"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb85-1"><a href="#cb85-1" aria-hidden="true" tabindex="-1"></a>(clojure.set/union #{<span class="dv">1</span> <span class="dv">2</span>} #{<span class="dv">2</span> <span class="dv">3</span>} #{<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span> <span class="dv">4</span>} #{<span class="dv">7</span> <span class="dv">8</span>}) <span class="co">;=&gt; #{1 2 3 4 7 8}</span></span>
<span id="cb85-2"><a href="#cb85-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">apply</span> clojure.set/union [#{<span class="dv">1</span> <span class="dv">2</span>} #{<span class="dv">5</span>} #{<span class="dv">7</span> <span class="dv">8</span>}])      <span class="co">;=&gt; #{1 2 5 7 8}</span></span></code></pre></div>
<p>That is, <code>union</code> works like <code>concat</code> but is
specialized for sets. Let’s put this into good use:</p>
<section class="alert alert-success">
<h3>
Exercise 24
</h3>
<p>Write the function <code>(authors books)</code> that returns the
authors of every book in <code>books</code> as a set.</p>
<div class="sourceCode" id="cb86"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a>(authors [cities, wild-seed])              <span class="co">;=&gt; #{china, octavia}</span></span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>(authors [cities, wild-seed, embassytown]) <span class="co">;=&gt; #{china, octavia}</span></span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>(authors [little-schemer, cities])         <span class="co">;=&gt; #{china, friedman, felleisen}</span></span></code></pre></div>
</section>
<p>Now that we have all of our authors, defining
<code>all-author-names</code> should be simple.</p>
<section class="alert alert-success">
<h3>
Exercise 25
</h3>
<p>Write the function <code>(all-author-names books)</code> that works
like the previous one and uses <code>authors</code>.</p>
<div class="sourceCode" id="cb87"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb87-1"><a href="#cb87-1" aria-hidden="true" tabindex="-1"></a>(all-author-names books)</span>
<span id="cb87-2"><a href="#cb87-2" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; #{&quot;Matthias Felleisen&quot; &quot;China Miéville&quot;</span></span>
<span id="cb87-3"><a href="#cb87-3" aria-hidden="true" tabindex="-1"></a><span class="co">;     &quot;Octavia E. Butler&quot; &quot;Daniel Friedman&quot;}</span></span>
<span id="cb87-4"><a href="#cb87-4" aria-hidden="true" tabindex="-1"></a>(all-author-names [cities, wild-seed])</span>
<span id="cb87-5"><a href="#cb87-5" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; #{&quot;China Miéville&quot; &quot;Octavia E. Butler&quot;}</span></span>
<span id="cb87-6"><a href="#cb87-6" aria-hidden="true" tabindex="-1"></a>(all-author-names []) <span class="co">;=&gt; #{}</span></span></code></pre></div>
</section>
<section id="string-representation-for-books" class="level3">
<h3>String Representation for Books</h3>
<p>Now that we have defined these books, I would like to have a readable
string representation for them. Let’s start by defining a representation
for a single author.</p>
<section class="alert alert-success">
<h3>
Exercise 26
</h3>
<p>Write the function <code>(author-&gt;string author)</code> that
returns a string representation of <code>author</code> as follows:</p>
<p>You can assume that every author with a <code>:death-year</code> also
has a <code>:birth-year</code>.</p>
<div class="sourceCode" id="cb88"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>(author-&gt;string felleisen) <span class="co">;=&gt; &quot;Matthias Felleisen&quot;</span></span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>(author-&gt;string friedman)  <span class="co">;=&gt; &quot;Daniel Friedman (1944 - )&quot;</span></span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>(author-&gt;string octavia)   <span class="co">;=&gt; &quot;Octavia E. Butler (1947 - 2006)&quot;</span></span></code></pre></div>
Hint: you probably want to split this string into two parts: name and
years. Use <code>let</code> to form these and use <code>str</code> to
create the final string.
</section>
<p>Now we have a string representation for a single author. Some of our
books had multiple authors, so we need to figure out a way to give a
string representation for multiple authors. To do this, we need a handy
helper function.</p>
<p>Sometimes you want to add something in between the elements of a
sequence. For that, there is <code>(interpose separator a-seq)</code>,
which returns a new sequence that has <code>separator</code> between
each element of <code>a-seq</code>.</p>
<div class="sourceCode" id="cb89"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb89-1"><a href="#cb89-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">interpose</span> <span class="st">&quot;:&quot;</span> [<span class="dv">1</span> <span class="dv">2</span> <span class="dv">3</span>])        <span class="co">;=&gt; (1 &quot;:&quot; 2 &quot;:&quot; 3)</span></span>
<span id="cb89-2"><a href="#cb89-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">interpose</span> <span class="st">&quot; and &quot;</span> [<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>]) <span class="co">;=&gt; (&quot;a&quot; &quot; and &quot; &quot;b&quot;)</span></span>
<span id="cb89-3"><a href="#cb89-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">interpose</span> <span class="st">&quot;, &quot;</span> [])            <span class="co">;=&gt; ()</span></span>
<span id="cb89-4"><a href="#cb89-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb89-5"><a href="#cb89-5" aria-hidden="true" tabindex="-1"></a>(<span class="kw">apply</span> <span class="kw">str</span> (<span class="kw">interpose</span> <span class="st">&quot; and &quot;</span> [<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>])) <span class="co">;=&gt; &quot;a and b&quot;</span></span></code></pre></div>
<p>With this, it shouldn’t be too hard to get a nice representation for
a sequence of authors.</p>
<section class="alert alert-success">
<h3>
Exercise 27
</h3>
<p>Write the function <code>(authors-&gt;string authors)</code> which
takes a sequence of authors as a parameter and returns a string
representation of <code>authors</code> in the following manner:</p>
<div class="sourceCode" id="cb90"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>(authors-&gt;string (<span class="at">:authors</span> little-schemer))</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; &quot;Daniel Friedman (1944 - ), Matthias Felleisen&quot;</span></span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a>(authors-&gt;string #{octavia})          <span class="co">;=&gt; &quot;Octavia E. Butler (1947 - 2006)&quot;</span></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>(authors-&gt;string #{})                 <span class="co">;=&gt; &quot;&quot;</span></span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>(authors-&gt;string #{octavia, friedman})</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; &quot;Octavia E. Butler (1947 - 2006), Daniel Friedman (1944 - )&quot;</span></span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a><span class="co">;   order doesn&#39;t matter</span></span></code></pre></div>
Since the authors are in a set, which doesn’t have a predefined order,
the resulting string can have the authors in any order.
</section>
<p>Now that we can handle the case of multiple authors, we can move on
to the string representation of a single book.</p>
<section class="alert alert-success">
<h3>
Exercise 28
</h3>
<p>Write the function <code>(book-&gt;string book)</code> takes a single
book as a parameter and returns a string representation of
<code>book</code> as follows:</p>
<div class="sourceCode" id="cb91"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>(book-&gt;string wild-seed) <span class="co">;=&gt; &quot;Wild Seed, written by Octavia E. Butler&quot;</span></span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>(book-&gt;string little-schemer)</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; &quot;The Little Schemer, written by Daniel Friedman (1944 - ), Matthias Felleisen&quot;</span></span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a><span class="co">;                                   ^-- order doesn&#39;t matter</span></span></code></pre></div>
Again, the order of authors in the string doesn’t matter.
</section>
<p>And finally, we can define a string representation for a sequence of
books.</p>
<section class="alert alert-success">
<h3>
Exercise 29
</h3>
<p>Write the function <code>(books-&gt;string books)</code> that takes a
sequence of books as a parameter and returns a string representation of
<code>books</code> like this:</p>
<div class="sourceCode" id="cb92"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>(books-&gt;string []) <span class="co">;=&gt; &quot;No books.&quot;</span></span>
<span id="cb92-2"><a href="#cb92-2" aria-hidden="true" tabindex="-1"></a>(books-&gt;string [cities])</span>
<span id="cb92-3"><a href="#cb92-3" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; &quot;1 book. The City and the City, written by China Miéville (1972 - ).&quot;</span></span>
<span id="cb92-4"><a href="#cb92-4" aria-hidden="true" tabindex="-1"></a>(books-&gt;string [little-schemer, cities, wild-seed])</span>
<span id="cb92-5"><a href="#cb92-5" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; &quot;3 books. The Little Schemer, written by Daniel Friedman (1944 - ), Matthias Felleisen. The City and the City, written by China Miéville (1972 - ). Wild Seed, written by Octavia E. Butler (1947 - 2006).&quot;</span></span></code></pre></div>
</section>
</section>
</section>
<section id="filtering-sequences" class="level2">
<h2>Filtering sequences</h2>
<p>Another common function besides <code>map</code> is
<code>filter</code>. It is used to select some elements of a sequence
and disregard the rest:</p>
<div class="sourceCode" id="cb93"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">filter</span> <span class="kw">pos?</span> [-<span class="dv">4</span> <span class="dv">6</span> -<span class="dv">2</span> <span class="dv">7</span> -<span class="dv">8</span> <span class="dv">3</span>])</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt;       (      6         7          3  )</span></span>
<span id="cb93-3"><a href="#cb93-3" aria-hidden="true" tabindex="-1"></a><span class="co">; value    -4    6    -2   7     -8   3</span></span>
<span id="cb93-4"><a href="#cb93-4" aria-hidden="true" tabindex="-1"></a><span class="co">; pos?   false true false true false true</span></span>
<span id="cb93-5"><a href="#cb93-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb93-6"><a href="#cb93-6" aria-hidden="true" tabindex="-1"></a>(<span class="kw">filter</span> (<span class="kw">fn</span> [x] (<span class="kw">&gt;</span> (<span class="kw">count</span> x) <span class="dv">2</span>)) [<span class="st">&quot;ff&quot;</span> <span class="st">&quot;f&quot;</span> <span class="st">&quot;ffffff&quot;</span> <span class="st">&quot;fff&quot;</span>])</span>
<span id="cb93-7"><a href="#cb93-7" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; (&quot;ffffff&quot; &quot;fff&quot;)</span></span></code></pre></div>
<p><code>(filter predicate collection)</code> takes two parameters, a
function and a sequencable collection. It calls <code>predicate</code>
(the function) on each element of <code>collection</code> and returns a
sequence of elements of <code>collection</code> for which
<code>predicate</code> returned a truthy value. In the above example the
values <code>(6 7 3)</code> were selected because for them
<code>pos?</code> returned <code>true</code>; for the others it returned
<code>false</code>, a falsey value, and they were filtered out.</p>
<section class="alert alert-success">
<h3>
Exercise 30
</h3>
<p>Write the function <code>(books-by-author author books)</code>.</p>
<p>Hint: <code>has-author?</code></p>
<div class="sourceCode" id="cb94"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb94-1"><a href="#cb94-1" aria-hidden="true" tabindex="-1"></a>(books-by-author china books)   <span class="co">;=&gt; (cities embassytown)</span></span>
<span id="cb94-2"><a href="#cb94-2" aria-hidden="true" tabindex="-1"></a>(books-by-author octavia books) <span class="co">;=&gt; (wild-seed)</span></span></code></pre></div>
</section>
<div class="sourceCode" id="cb95"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> authors </span>#{china, felleisen, octavia, friedman})</span></code></pre></div>
<section class="alert alert-success">
<h3>
Exercise 31
</h3>
<p>Write the function <code>(author-by-name name authors)</code> that
takes a string <code>name</code> and a sequence of authors and returns
an author with the given name if one is found. If one is not found, then
<code>nil</code> should be returned.</p>
<p>Hint: remember <code>first</code></p>
<div class="sourceCode" id="cb96"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb96-1"><a href="#cb96-1" aria-hidden="true" tabindex="-1"></a>(author-by-name <span class="st">&quot;Octavia E. Butler&quot;</span> authors)                <span class="co">;=&gt; octavia</span></span>
<span id="cb96-2"><a href="#cb96-2" aria-hidden="true" tabindex="-1"></a>(author-by-name <span class="st">&quot;Octavia E. Butler&quot;</span> #{felleisen, friedman}) <span class="co">;=&gt; nil</span></span>
<span id="cb96-3"><a href="#cb96-3" aria-hidden="true" tabindex="-1"></a>(author-by-name <span class="st">&quot;China Miéville&quot;</span> authors)                   <span class="co">;=&gt; china</span></span>
<span id="cb96-4"><a href="#cb96-4" aria-hidden="true" tabindex="-1"></a>(author-by-name <span class="st">&quot;Goerge R. R. Martin&quot;</span> authors)              <span class="co">;=&gt; nil</span></span></code></pre></div>
</section>
<section class="alert alert-success">
<h3>
Exercise 32
</h3>
<p>Write the function <code>(living-authors authors)</code> that takes a
sequence of authors and returns those that are alive. Remember
<code>alive?</code>.</p>
<div class="sourceCode" id="cb97"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a>(living-authors authors)             <span class="co">;=&gt; (china, felleisen, friedman)</span></span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a>(living-authors #{octavia})          <span class="co">;=&gt; ()</span></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a>(living-authors #{china, felleisen}) <span class="co">;=&gt; (china, felleisen)</span></span></code></pre></div>
The order in the results doesn’t matter.
</section>
<p>Here’s another book. This one has both living and dead authors, which
is a useful test case for the following exercises.</p>
<div class="sourceCode" id="cb98"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> jrrtolkien </span>{<span class="at">:name</span> <span class="st">&quot;J. R. R. Tolkien&quot;</span> <span class="at">:birth-year</span> <span class="dv">1892</span> <span class="at">:death-year</span> <span class="dv">1973</span>})</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> christopher </span>{<span class="at">:name</span> <span class="st">&quot;Christopher Tolkien&quot;</span> <span class="at">:birth-year</span> <span class="dv">1924</span>})</span>
<span id="cb98-3"><a href="#cb98-3" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> kay </span>{<span class="at">:name</span> <span class="st">&quot;Guy Gavriel Kay&quot;</span> <span class="at">:birth-year</span> <span class="dv">1954</span>})</span>
<span id="cb98-4"><a href="#cb98-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb98-5"><a href="#cb98-5" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> silmarillion </span>{<span class="at">:title</span> <span class="st">&quot;Silmarillion&quot;</span></span>
<span id="cb98-6"><a href="#cb98-6" aria-hidden="true" tabindex="-1"></a>                   <span class="at">:authors</span> #{jrrtolkien, christopher, kay}})</span></code></pre></div>
<p>And here’s another with multiple dead authors:</p>
<div class="sourceCode" id="cb99"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> dick </span>{<span class="at">:name</span> <span class="st">&quot;Philip K. Dick&quot;</span>, <span class="at">:birth-year</span> <span class="dv">1928</span>, <span class="at">:death-year</span> <span class="dv">1982</span>})</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> zelazny </span>{<span class="at">:name</span> <span class="st">&quot;Roger Zelazny&quot;</span>, <span class="at">:birth-year</span> <span class="dv">1937</span>, <span class="at">:death-year</span> <span class="dv">1995</span>})</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>(<span class="bu">def</span><span class="fu"> deus-irae </span>{<span class="at">:title</span> <span class="st">&quot;Deus Irae&quot;</span>, <span class="at">:authors</span> #{dick, zelazny}})</span></code></pre></div>
<p>If you want to know whether a collection is empty or not, you can use
<code>(empty? coll)</code> to do that.</p>
<div class="sourceCode" id="cb100"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">empty?</span> [])  <span class="co">;=&gt; true</span></span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">empty?</span> #{}) <span class="co">;=&gt; true</span></span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">empty?</span> [<span class="dv">1</span>]) <span class="co">;=&gt; false</span></span></code></pre></div>
<section class="alert alert-success">
<h3>
Exercise 33
</h3>
<p>Write the function <code>(has-a-living-author? book)</code> that
returns <code>true</code> if <code>book</code> has a living author, and
otherwise <code>false</code>.</p>
<div class="sourceCode" id="cb101"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>(has-a-living-author? wild-seed)      <span class="co">;=&gt; false</span></span>
<span id="cb101-2"><a href="#cb101-2" aria-hidden="true" tabindex="-1"></a>(has-a-living-author? silmarillion)   <span class="co">;=&gt; true</span></span>
<span id="cb101-3"><a href="#cb101-3" aria-hidden="true" tabindex="-1"></a>(has-a-living-author? little-schemer) <span class="co">;=&gt; true</span></span>
<span id="cb101-4"><a href="#cb101-4" aria-hidden="true" tabindex="-1"></a>(has-a-living-author? cities)         <span class="co">;=&gt; true</span></span>
<span id="cb101-5"><a href="#cb101-5" aria-hidden="true" tabindex="-1"></a>(has-a-living-author? deus-irae)      <span class="co">;=&gt; false</span></span></code></pre></div>
</section>
<section class="alert alert-success">
<h3>
Exercise 34
</h3>
<p>Write the function <code>(books-by-living-authors books)</code> that
takes a sequence of books as a parameter and returns those that have a
living author.</p>
<div class="sourceCode" id="cb102"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>(books-by-living-authors books) <span class="co">;=&gt; (little-schemer cities embassytown)</span></span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>(books-by-living-authors (<span class="kw">concat</span> books [deus-irae, silmarillion]))</span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a><span class="co">;=&gt; (little-schemer cities embassytown silmarillion)</span></span></code></pre></div>
</section>
<section id="keeping-your-vectors" class="level3">
<h3>Keeping your vectors</h3>
<p><code>map</code> and <code>filter</code> always return sequences,
regardless of the collection type given as a parameter. Sometimes,
however, you want the result to be a vector. For an example, you may
want to index the vector afterwards. In this situation, you can use
<code>mapv</code> and <code>filterv</code>, which are variants of
<code>map</code> and <code>filter</code> that always return vectors.</p>
<div class="sourceCode" id="cb103"><pre
class="sourceCode clojure"><code class="sourceCode clojure"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>(<span class="kw">mapv</span> ... [...])    <span class="co">;=&gt; [...]</span></span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a>(<span class="kw">filterv</span> <span class="kw">pos?</span> [-<span class="dv">4</span> <span class="dv">6</span> -<span class="dv">2</span> <span class="dv">7</span> -<span class="dv">8</span> <span class="dv">3</span>])  <span class="co">;=&gt; [6 7 3]</span></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>(<span class="kw">filterv</span> <span class="kw">pos?</span> #{-<span class="dv">4</span> <span class="dv">6</span> -<span class="dv">2</span> <span class="dv">7</span> -<span class="dv">8</span> <span class="dv">3</span>}) <span class="co">;=&gt; [3 6 7]</span></span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>(<span class="kw">mapv</span> ... #{...})   <span class="co">;=&gt; [...]</span></span></code></pre></div>
</section>
</section>
<section id="done" class="level2">
<h2>Done!</h2>
<p>Phew, that was quite a lot of stuff.</p>
<p><a href="style.html">Clojure with Style →</a></p>
</section>
<footer>
    <p>
        &copy; iloveponies

        <span style="float: right">
            <a href="mailto:juhana.laurinharju@cs.helsinki.fi">questions?</a>
        </span>
    </p>
</footer>
</div>
</div>
</body>
</html>
